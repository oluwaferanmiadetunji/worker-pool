// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const claimNextWebhook = `-- name: ClaimNextWebhook :one
UPDATE webhook_events
SET status = 'processing', attempts = attempts + 1, updated_at = CURRENT_TIMESTAMP
WHERE id = (
  SELECT id FROM webhook_events
  WHERE status = 'received'
  ORDER BY received_at ASC
  LIMIT 1
  FOR UPDATE SKIP LOCKED
)
RETURNING id, event_id, type, payload, status, attempts, last_error, received_at, processed_at, updated_at
`

func (q *Queries) ClaimNextWebhook(ctx context.Context) (WebhookEvent, error) {
	row := q.db.QueryRow(ctx, claimNextWebhook)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.LastError,
		&i.ReceivedAt,
		&i.ProcessedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO webhook_events (event_id, type, payload) VALUES ($1, $2, $3)
RETURNING id, event_id, type, payload, status, attempts, last_error, received_at, processed_at, updated_at
`

type CreateWebhookParams struct {
	EventID string  `json:"event_id"`
	Type    *string `json:"type"`
	Payload []byte  `json:"payload"`
}

func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (WebhookEvent, error) {
	row := q.db.QueryRow(ctx, createWebhook, arg.EventID, arg.Type, arg.Payload)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.LastError,
		&i.ReceivedAt,
		&i.ProcessedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markWebhookDone = `-- name: MarkWebhookDone :one
UPDATE webhook_events
SET status = 'done', processed_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, event_id, type, payload, status, attempts, last_error, received_at, processed_at, updated_at
`

func (q *Queries) MarkWebhookDone(ctx context.Context, id uuid.UUID) (WebhookEvent, error) {
	row := q.db.QueryRow(ctx, markWebhookDone, id)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.LastError,
		&i.ReceivedAt,
		&i.ProcessedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markWebhookFailed = `-- name: MarkWebhookFailed :one
UPDATE webhook_events
SET status = 'failed', last_error = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, event_id, type, payload, status, attempts, last_error, received_at, processed_at, updated_at
`

type MarkWebhookFailedParams struct {
	ID        uuid.UUID `json:"id"`
	LastError *string   `json:"last_error"`
}

func (q *Queries) MarkWebhookFailed(ctx context.Context, arg MarkWebhookFailedParams) (WebhookEvent, error) {
	row := q.db.QueryRow(ctx, markWebhookFailed, arg.ID, arg.LastError)
	var i WebhookEvent
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.LastError,
		&i.ReceivedAt,
		&i.ProcessedAt,
		&i.UpdatedAt,
	)
	return i, err
}
